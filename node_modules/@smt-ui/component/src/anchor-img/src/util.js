/**
 * @file 锚点图片相关Ui及数据处理逻辑
 * @author chaiyixin
*/

import {ANCHOR_TYPE, IMG_MODE} from '../../common/utils/consts';
  /**
 * 锚点文本截断
 *
 * @param {string} str 锚点文本
 * @param {number} fontCount 文本最大字数
 * @return {string}
 */
function getFilterText(str, fontCount) {
    return str.length > fontCount ? `${str.slice(0, fontCount)}...` : str;
}

 /**
 * 获取锚点定位
 *
 * @param {Object} anchor 锚点对象
 * @param {ANCHOR_TYPE} anchor.type 锚点类型
 * @param {string} anchor.type 锚点类型
 * @param {number} anchor.ordinate 锚点类型
 * @param {number} anchor.abscissa 原图宽
 * @param {number} anchor.position 原图高
 * @param {string} anchor.text 图片展示模式
 * @param {Object} props 组件属性
 * @param {number} imgRadio 原图宽/实际展示宽
 * @return {string}  锚点方向'left/right'
 */
function getCalcPosition(anchor, {maxFontCount, fontSize, roundSize, originWidth}, imgRadio) {
    if (anchor.position) {
        return anchor.position;
    } else {
        let maxTagWidth = 0;
        const padWidth = fontSize * 5 / 6 * 2;
        const fontCount = anchor.type === ANCHOR_TYPE.PRIMARY ? maxFontCount + 2 : maxFontCount;
        const textWidth = fontSize * fontCount;
        if (anchor.type === ANCHOR_TYPE.PRIMARY) {
            maxTagWidth = textWidth + padWidth + (fontSize + fontSize / 2) * 2;
        } else {
            maxTagWidth = textWidth + padWidth;
        }
        const roundLeftToLine = 2 * roundSize;
        const imgBgWidth = originWidth * imgRadio;
        if (anchor.abscissa * imgRadio < imgBgWidth / 2) {
            return anchor.abscissa * imgRadio < maxTagWidth + roundLeftToLine ? 'right' : 'left';
        } else {
            return imgBgWidth - anchor.abscissa * imgRadio > maxTagWidth + roundLeftToLine ? 'right' : 'left';
        }
    }
}

/**
 * 设置锚点样式
 *
 * @param {Object} anchor 锚点对象
 * @param {number} imgRadio 原图宽/实际展示宽
 * @param {number} roundSize 锚点圆直径
 * @return {Object}
 */
function getItemStyle(anchor, imgRadio, roundSize) {
    return {
        left: `${anchor.abscissa * imgRadio}px`,
        top: `${anchor.ordinate * imgRadio}px`,
        transform: `translate(-${roundSize / 2}px,-${roundSize / 2}px)`
    };
}

export default {
    /**
     * 获取锚点背景图片实际大小
     *
     * @param {number} radio 原图宽/实际展示宽
     * @param {number} originWidth 原图宽
     * @param {number} originHeight 原图高
     * @param {IMG_MODE} mode 图片展示模式
     * @return {Object}
     */
    getConSize(radio, originWidth, originHeight, mode) {
        if (radio) {
            if (mode === IMG_MODE.WIDTH_FIX) {
                return {
                    height: '100%',
                    width: '100%'
                };
            } else {
                if (originWidth > originHeight) {
                    return {
                        width: '100%',
                        height: radio * originHeight + 'px'
                    };
                } else {
                    return {
                        height: '100%',
                        width: radio * originWidth + 'px'
                    };
                }
            }
        } else {
            return {
                height: '0px',
                width: '0px'
            };
        }
    },

    /**
     * 获取真实的锚点列表
     *
     * @param {Array}  list 锚点列表
     * @param {Object} props 组件属性
     * @param {number} imgRadio 原图宽/实际展示宽
     * @return {Array}
     */
    getAnchorList(list, attrs, imgRadio) {
        const {maxFontCount, roundSize} = attrs;
        return list.map(anchor => {
            anchor.text = getFilterText(anchor.text, maxFontCount);
            return {
                style: getItemStyle(anchor, imgRadio, roundSize),
                position: getCalcPosition(anchor, attrs, imgRadio),
                state: anchor
            };
        });
    },

    /**
     * 获取转义的svg图标颜色 #ffffff => %23ffffff
     *
     * @param {string}  hexColor 图标颜色
     * @return {string}
     */
    getSvgColor(hexColor) {
        if (hexColor && hexColor.charAt(0) === '#') {
            return '%23' + hexColor.slice(1);
        }
        return hexColor;
    }

};